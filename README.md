# Project 3: Parallel Cryptocurrency Miner (v 1.0)

See spec here: https://www.cs.usfca.edu/~mmalensek/cs521/assignments/project-3.html

## Overview
Hashcash is a proof-of-work system, using computationally expensive problem to prove its action is legitimate. In the past, this has been used to limit email spam and denial-of-service attacks. Nowadays, it is being used in all cryptocurrencies such as: Bitcoin, Etherium, Dogecoin and others as part of the mining algorithm.

Using this idea, we are creating our own <i>"cryptocurrency"</i>.

The goal of this project is to be able to understand:
- The pthread library and parallelization using threads
- The producer/consumer paradigm
- Taking performance measurements

## Implementation
The main challenge in this project is to figure out how to optimize our algorithm to find the nonce using multi-threading while avoiding deadlock. This project is one of many examples where we can use producer-consumer setup.

The producer will generate tasks which consists of the range of the nonces and store it in a circular array. While the array is full or still consist of a certain number of tasks, the producer will wait a signal from the consumer. While there are many ways to implement this, in this project we are using ```condition variables``` such as: ```pthread_cond_wait() and pthread_cond_signal()```.

On the other hand, on the consumer side, while the task is not empty or nonce has not been found, it will keep consuming the tasks generated by the producer. If there are no more tasks, the consumer will send a wake up signal to the producer to tell the producer to produce more tasks. Otherwise, that when we find the hash or correct nonce, we will send a broadcast signal to all the threads to stop using ```pthread_cond_broadcast()```.

## How to Run the Program
<b> Syntax: </b>
```./miner num_of_threads num_of_difficulties 'any_block_data'```

<b> Example: </b>
```./miner 128 8 'This is a test!'```
```
Number of threads: 128
  Difficulty Mask: 00000000111111111111111111111111
       Block data: [This is a test!]

----------- Starting up miner threads!  -----------
final buffer= 0
Solution found by thread 6:
Nonce: 334
 Hash: 001EB7E1E58A9E204A453FC2B2A43CB39D7FA22C
331 hashes in 0.02s (16997.83 hashes/sec)
```

## List of files

* <b>miner.c :</b>  This is the main driver of the program. It is calling the ui.c and history.c repeatedly to get, tokenize and execute commands from the user. 
* <b>sha1.c :</b> This file is mainly responsible for the user interface of the shell. 
* <b>Makefile</b>: Run and compile the program

## Unit testing
<b>List of Tests:</b>
1.  <b> Difficulty </b> - Test whether our program is able to read the difficulty level from the user input and convert those number to 32 bits. The difficulty level will determine the number of zeroes that we need to find in a hash.
2.  <b> Thread Creation </b> - Test the program whether our program able to generate threads according to the user input
4.  <b> Correct Nonces </b> - Check whether our program is able to find nonces that produce hash with the correct number of zeroes depending on the number of difficulty
5.  <b> Speedup </b> - Measuring the performance of our parallel program. <i> S = T_serial / T_parallel </i>
7.  <b> Documentation </b> - Test whether each files has proper documentation explaining their functionality
8.  <b> Static Analysis </b> - Check if there are any redundant in our code
9.  <b> Leak Check </b> - Check if this program has memory leak

<b>Syntax used to test:</b>

- ```make test``` - To test the whole tests
- ```make test run=x``` - To test specific case of x, where x is the test number
- ```make test run={x, y, ..., z}``` - To test few specific cases where {x, y, ...., z} is the test number
